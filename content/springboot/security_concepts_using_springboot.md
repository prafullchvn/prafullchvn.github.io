---
title: "Security_concepts_using_springboot"
date: 2024-04-02T16:25:46+05:30
draft: false
tags: 
  - springboot
  - security
---

# Security Concepts using Spring Boot

There are many ways to secure your application using spring boot. Some of the ways are as follows:
1. Basic Authentication & Authorization
2. OAuth2
3. JWT
4. CORS & CSRF

## Basic Authentication & Authorization

Basic Authentication is the simplest way to secure your application. It is based on the username and password. It is not recommended to use this in production as it is not secure. But it is good to use in development environment.

To use basic authentication, you need to add the following dependency in your `build.gradle` file:

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-security'
}
```

After adding the dependency, you need to add the following configuration in your `application.properties` file:

```properties
spring.security.user.name=user
spring.security.user.password=password
```

After adding the configuration, you can access the application using the username and password. The default username is `user` and password is `password`. This package by default will authenticate all the requests. If you want to authenticate only specific requests, you can use the following configuration:

```kotlin
@Configuration
class SecurityConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http.authorizeRequests()
            .antMatchers("/api/**").authenticated()
            .anyRequest().permitAll()
            .formLogin()
            .and()
            .httpBasic()
    }
}
```

Here the all the requests which starts with `/api/` will be authenticated and all other requests will be permitted.`.formLogin()` is used to enable the form login and `.httpBasic()` is used to enable the basic authentication. You can deny all the requests by using `.denyAll()` and permit all the requests by using `.permitAll()`.

How to make username and password dynamic using mongodb

```kotlin
@Configuration
class SecurityConfig : WebSecurityConfigurerAdapter() {
    @Autowired
    lateinit var userRepository: UserRepository

    override fun configure(http: HttpSecurity) {
        http.authorizeRequests()
            .antMatchers("/api/**").authenticated()
            .anyRequest().permitAll()
            .formLogin()
            .and()
            .httpBasic()
            .and()
            .userDetailsService(userDetailsService())
    }

    @Bean
    fun userDetailsService(): UserDetailsService {
        return UserDetailsService {
            val user = userRepository.findByUsername(it)
            if (user != null) {
                return@UserDetailsService User.withDefaultPasswordEncoder()
                    .username(user.username)
                    .password(user.password)
                    .authorities(user.authorities)
                    .build()
            } else {
                throw UsernameNotFoundException("User not found")
            }
        }
    }
}
```

We can define password encoder as follows:

```kotlin
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

## OAuth2

OAuth2 is an authorization framework that enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf. OAuth2 is used to secure the application by providing the access token. The access token is used to access the resources. The access token is generated by the authorization server. The authorization server is responsible for generating the access token and validating the access token.

To use OAuth2, you need to add the following dependency in your `build.gradle` file:

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
}
```


 You can use any other authorization server as well. You can use the following configuration to use the custom authorization

```kotlin
    @Configuration
    class OAuth2Config : WebSecurityConfigurerAdapter() {
        override fun configure(http: HttpSecurity) {
            http.oauth2Login()
                .loginPage("/login")
                .userInfoEndpoint()
                .userService(oauth2UserService())
        }

        @Bean
        fun oauth2UserService(): OAuth2UserService<OAuth2UserRequest, OAuth2User> {
            return OAuth2UserService { userRequest ->
                val clientRegistration = userRequest.clientRegistration
                val userInfoEndpointUri = clientRegistration.providerDetails.userInfoEndpoint.uri
                if (!StringUtils.hasText(userInfoEndpointUri)) {
                    throw RuntimeException("User info endpoint URI not found")
                }

                val restTemplate = RestTemplate()
                val headers = HttpHeaders()
                headers.add(HttpHeaders.AUTHORIZATION, "Bearer ${userRequest.accessToken.tokenValue}")
                val entity = HttpEntity("", headers)
                val response = restTemplate.exchange(userInfoEndpointUri, HttpMethod.GET, entity, Map::class.java)
                val userAttributes = response.body

                return DefaultOAuth2User(
                    emptyList(),
                    userAttributes,
                    clientRegistration.providerDetails.userInfoEndpoint.userNameAttributeName
                )
            }
        }
    }
```

## JWT

JWT stands for 'JSON Web Token'. It is an open standard that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.  The access token is used to access the resources. The access token is generated by the authorization server. The authorization server is responsible for creating the token when user authenticates themselves as well as  validating the access token.

On every request, the client sends the access token to the server. The server validates the access token and sends the response back. 

![JWT](/public/images/jwt.png)

To use JWT, you need to add the following dependency in your `build.gradle` file:

### Advantages of JWT

1. Token helps us share the credentials between the client and the server.
2. Token gives us flexibility of invalidating the session with invalidating the credentials.
3. Token can be created for short time span
4. Token can be used to store the information such as user role, user id etc.
5. Token are stateless allows us to load balance the requests of user to different servers.

JWT Token has 3 parts each separated by (.) dot. The three parts are as follows:

1. Header : Contains information about the type of token and the algorithm used to sign the token.
2. Payload : Contains the claims. Claims are statements about an entity (typically, the user) and additional data.
3. Signature : Signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.

Create JWT Token filter

```kotlin
interface SecurityConstants {
    companion object {
        const val JWT_KEY = "jxgEQeXHuPq8VdbyYFNkANdudQ53YUn4"
        const val JWT_HEADER = "Authorization"
    }
}
```

Using above constants, we can create the JWT token filter as follows:

```kotlin
class JWTTokenGeneratorFilter : OncePerRequestFilter() {

    @Throws(ServletException::class, IOException::class)
    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {
        val authentication: Authentication? = SecurityContextHolder.getContext().authentication
        if (authentication != null) {
            val key: SecretKey = Keys.hmacShaKeyFor(SecurityConstants.JWT_KEY.toByteArray(StandardCharsets.UTF_8))
            val jwt: String = Jwts.builder()
                .setIssuer("Eazy Bank")
                .setSubject("JWT Token")
                .claim("username", authentication.name)
                .claim("authorities", populateAuthorities(authentication.authorities))
                .setIssuedAt(Date())
                .setExpiration(Date(System.currentTimeMillis() + 30000000))
                .signWith(key)
                .compact()
            response.setHeader(SecurityConstants.JWT_HEADER, jwt)
        }
        filterChain.doFilter(request, response)
    }

    private fun populateAuthorities(authorities: Collection<*>): String {
        return authorities.joinToString(",") { it.toString() }
    }
}
```

Above code will generate the JWT token and set it in the header. The token will be valid for 5 minutes. You can change the time as per your requirement. You can also add the claims as per your requirement. The claims are the information that you want to store in the token.

To exclude the JWT token filter for specific requests, you can use the following configuration:

```kotlin
@Override
protected boolean shouldNotFilter(HttpServletRequest request) {
    return !request.getServletPath().equals("/user");
}
```

Creating the validator for the JWT token
    
```kotlin
class JWTTokenValidatorFilter : AbstractPreAuthenticatedProcessingFilter() {

    @Throws(ServletException::class, IOException::class)
    override fun doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain) {
        val jwt = request.getHeader(SecurityConstants.JWT_HEADER)
        if (jwt != null) {
            try {
                val key: SecretKey = Keys.hmacShaKeyFor(SecurityConstants.JWT_KEY.toByteArray(StandardCharsets.UTF_8))
                val claims: Claims = Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(jwt)
                    .body
                val username = claims["username"].toString()
                val authorities = claims["authorities"] as String
                val auth = UsernamePasswordAuthenticationToken(username, null,
                    AuthorityUtils.commaSeparatedStringToAuthorityList(authorities))
                SecurityContextHolder.getContext().authentication = auth
            } catch (e: Exception) {
                throw BadCredentialsException("Invalid Token received!")
            }
        }
        filterChain.doFilter(request, response)
    }
}
```

Adding filter to the security configuration

```kotlin
@Configuration
@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    @Throws(Exception::class)
    override fun configure(http: HttpSecurity) {
        http.addFilterBefore(JWTTokenGeneratorFilter(), UsernamePasswordAuthenticationFilter::class.java)
        http.addFilterBefore(JWTTokenValidatorFilter(), UsernamePasswordAuthenticationFilter::class.java)
    }
}
```


## CORS & CSRF

CORS stands for Cross-Origin Resource Sharing. It is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It is used to secure the application by allowing the resources to be requested from another domain. It is used to secure the application by allowing the resources to be requested from another domain.

To use CORS, you need to add the following dependency in your `build.gradle` file:

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-security'
}
```

To add the CORS configuration, you can use the following configuration:

```kotlin
@Configuration
class SecurityConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http.cors(
            cors -> cors.configurationSource {
                val configuration = CorsConfiguration()
                configuration.allowedOrigins = listOf("*")
                configuration.allowedMethods = listOf("GET", "POST", "PUT", "DELETE")
                configuration.allowedHeaders = listOf("*")
                configuration.allowCredentials = true
                configuration.maxAge = 3600L
                configuration
            }
        )
    }
}
```

In above methods `allowedOrigins` is used to specify the origins from where the requests are allowed. `allowedMethods` is used to specify the methods that are allowed. `allowedHeaders` is used to specify the headers that are allowed. `allowCredentials` is used to specify whether the credentials are allowed. `maxAge` is used to specify the maximum age of the request.



